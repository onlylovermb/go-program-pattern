## 策略模式是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。

### 问题
假设你要设计一个类似redis的缓存数据库，redis有不同的缓存淘汰策略（lfu,lru,random等），那么希望将淘汰策略算法与redis类本身隔离开来，redis类中只保留对策略对象的引用（通过抽象的统一接口），每新增一个算法只需新增淘汰策略类即可，实现业务逻辑和算法实现的隔离。

### 解决方案
假如你要设计一个缓存类（cache）,缓存有多种不同的的淘汰策略算法（lru,lfu,fifo,random等），那么就可以使用策略模式将每种算法写入独自的类（lru,lfu...）中，并声明一个通用的算法策略接口（evictionAlgo）,每种算法类均实现此策略接口。缓存类（cache）中添加一个成员变量（evictionAlgo）用于保存对策略对象的引用。缓存类（cache）仅可通过策略接口同策略对象进行交互。
### 应用场景
- 当你想使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。
- 当你有许多仅在执行某些行为时略有不同的相似类时， 可使用策略模式。
- 如果算法在上下文的逻辑中不是特别重要， 使用该模式能将类的业务逻辑与其算法实现细节隔离开来。
- 当类中使用了复杂条件运算符以在同一算法的不同变体中切换时， 可使用该模式。
### 实现方式
1. 从上下文类（cache）中找出修改频率较高的算法（lru,lfu,fifo） （也可能是用于在运行时选择某个算法变体的复杂条件运算符）。
2. 声明该算法所有变体的通用策略接口(evictionAlgo)。
3. 将算法逐一抽取到各自的类(lru,lfu,fifo)中， 它们都必须实现策略接口(实现evict(c *cache)方法)
4. 在上下文类中添加一个成员变量(evictionAlgo)用于保存对于策略对象的引用。 然后提供设置器(setEvictionAlgo)以修改该成员变量。 上下文(cache)仅可通过策略接口同策略对象进行交互， 如有需要还可定义一个接口(通过传入在策略接口方法中传入c *cache)来让策略访问其数据。
5. 客户端必须将上下文类与相应策略进行关联， 使上下文可以预期的方式完成其主要工作。